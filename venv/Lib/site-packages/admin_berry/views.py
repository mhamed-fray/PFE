from django.shortcuts import render, redirect
from admin_berry.forms import LoginForm, RegistrationForm, UserPasswordResetForm, UserSetPasswordForm, UserPasswordChangeForm
from django.contrib.auth import logout
from django.shortcuts import render
import pandas as pd
import numpy as np
import pickle
from django.contrib.auth import views as auth_views
from sklearn.linear_model import LinearRegression
from .models import YourModel
from django.shortcuts import render
import pandas as pd
import numpy as np
import pickle
from django.shortcuts import render
from django.http import HttpResponse
import pickle
import numpy as np
from django.http import JsonResponse
from django.contrib.auth.models import User
from django.core.mail import send_mail
from django.conf import settings
from django.core.mail import send_mail
import logging
import smtplib
from email.mime.text import MIMEText
from email.mime.multipart import MIMEMultipart
import requests


# Create your views here.

def index(request):
  return render(request, 'pages/index.html')

def typography(request):
  return render(request, 'pages/typography.html')

def color(request):
  return render(request, 'pages/color.html')

def icon_tabler(request):
  return render(request, 'pages/icon-tabler.html')

def sample_page(request):
  return render(request, 'pages/sample-page.html')

  


# Authentication
def registration(request):
    if request.method == 'POST':
        form = RegistrationForm(request.POST)
        if form.is_valid():
            form.save()

            # Get the user's email from the form
            user_email = form.cleaned_data.get('email')

            # Send email to admin
            send_registration_email_to_admin(user_email)

            print('Account created successfully!')
            return redirect('/accounts/login/')
        else:
            print("Registration failed!")
    else:
        form = RegistrationForm()

    context = {'form': form}
    return render(request, 'accounts/register.html', context)
def send_registration_email_to_admin(user_email):
    sender_email = "fraymhamed8@gmail.com"  # Replace with your email
    receiver_email = "fraymhamed8@gmail.com"  # Replace with your admin's email
    password = "phqj dhlw cxln bsaa"  # Replace with your email password

    # Get user location
    user_location = get_user_location(user_email)

    message = MIMEMultipart("alternative")
    message["Subject"] = "New User Registration Notification"
    message["From"] = sender_email
    message["To"] = receiver_email

    # Construct email text with user's email and location
    text = f'A new user with email {user_email} has registered on your website. Location: {user_location}'

    part1 = MIMEText(text, "plain")
    message.attach(part1)

    with smtplib.SMTP("smtp.gmail.com", 587) as server:
        server.starttls()
        server.login(sender_email, password)
        server.sendmail(sender_email, receiver_email, message.as_string())
def get_user_location(user_email):
    # This function retrieves the user's location based on their IP address
    # Replace "your-api-key" with your actual API key from the geolocation service provider
    api_key = "03ad82a0a0d88a"
    
    # Dummy IP address, replace it with the actual IP address of the user
    # This might be obtained from the user's activity log or by other means
    user_ip = "196.179.196.107"

    # API request to get geolocation data
    url = f"https://ipinfo.io/196.179.196.107/json?token=03ad82a0a0d88a"
    response = requests.get(url)
    

    # Check if the request was successful
    if response.status_code == 200:
        data = response.json()
        # Extract location information
        city = data.get("city")
        country = data.get("country")
        return f"{city}, {country}" if city and country else "Unknown"
    else:
        # If the request fails, return "Unknown" location
        return "Unknown"

# Example usage
user_email = "fraymhamed8@gmail.com"
user_location = get_user_location(user_email)
print(f"The location of user {user_email} is: {user_location}")

class UserLoginView(auth_views.LoginView):
  template_name = 'accounts/login.html'
  form_class = LoginForm
  success_url = '/'

class UserPasswordResetView(auth_views.PasswordResetView):
  template_name = 'accounts/password_reset.html'
  form_class = UserPasswordResetForm

class UserPasswordResetConfirmView(auth_views.PasswordResetConfirmView):
  template_name = 'accounts/password_reset_confirm.html'
  form_class = UserSetPasswordForm

class UserPasswordChangeView(auth_views.PasswordChangeView):
  template_name = 'accounts/password_change.html'
  form_class = UserPasswordChangeForm

def user_logout_view(request):
  logout(request)
  return redirect('/accounts/login/')


def predict_view(mois):
    try:
        mois = int(mois)
    except ValueError:
        return 'error'

    with open('C:/Users/MSI/Desktop/stage2/ND/model_a.pkl', 'rb') as file:
        model = pickle.load(file)

    prediction = model.predict([[mois]]) 
    print(mois)
    print(prediction)
     # Assuming your model expects a 2D array

    if prediction > 90:
        return 'La prédiction  pour le mois {}  est supérieure à 90'.format(mois)
    elif prediction < 90:
        return 'La prédiction pour le mois {} est inférieure à 90'.format(mois)
    else:
        return 'error'

def result(request):
    mois = request.GET.get('mois', '')  


    result = predict_view(mois)

    return render(request, 'fray.html', {'result': result})





# Charger le modèle à partir du fichier pickle
with open('C:/Users/MSI/Desktop/stage2/ND/modele_regression_lineaire2.pkl', 'rb') as f:
    model = pickle.load(f)

def predict_sales(request):
    if request.method == 'POST':
        # Capturer les données d'entrée de l'utilisateur depuis la requête POST
        age = float(request.POST['age'])
        sex = int(request.POST['sex'])
        income = float(request.POST['income'])
        education_level = float(request.POST['education_level'])
        marital_status = int(request.POST['marital_status'])
        average_basket_size = float(request.POST['average_basket_size'])
        purchase_frequency = float(request.POST['purchase_frequency'])
        customer_segment = float(request.POST['customer_segment'])

        # Créer un DataFrame avec les données d'entrée
        new_data = pd.DataFrame({
            'Age': [age],
            'Sex': [sex],
            'Income': [income],
            'Education_Level': [education_level],
            'Marital_Status': [marital_status],
            'Average_Basket_Size': [average_basket_size],
            'Purchase_Frequency': [purchase_frequency],
            'Customer_Segment': [customer_segment]
        })

        # Faire une prédiction avec le modèle chargé
        prediction = model.predict(new_data)
        valeur_absolue = abs(prediction)
        # Arrondir la prédiction à l'entier le plus proche
        prediction_rounded = round(valeur_absolue[0])

        # Afficher la prédiction arrondie avec l'unité de devise
        return render(request, 'prediction_result.html', {'prediction': prediction_rounded})
    else:
        return render(request, 'predict_sales.html')
    

    #prediction2
def show_sales_prediction_interface(request):
    if request.method == 'POST':
        try:
            # Charger les données à partir du fichier CSV
            sales_data = pd.read_csv('C:/Users/MSI/Desktop/stage2/ND/sales_data1.csv')

            # Séparer les fonctionnalités (X) et la cible (y)
            X = sales_data.drop(columns=['Store ID'])
            y = sales_data.drop(columns=['Store ID'])  

            # Initialiser le modèle de régression linéaire
            model = LinearRegression()
            model.fit(X, y)
            with open('C:/Users/MSI/Desktop/stage2/ND/linear_regression_model11.pkl', 'wb') as f:
                pickle.dump(model, f)

            # Fonction pour prédire les ventes en fonction des valeurs saisies par l'utilisateur
            input_values = [float(request.POST[f'month_{i}']) for i in range(1, 13)]

            # Vérifier si les valeurs de ventes mensuelles sont dans la plage spécifiée
            if all(1000 <= value <= 100000 for value in input_values):
                input_array = np.array(input_values).reshape(1, -1)
                prediction = model.predict(input_array)

                # Transformer la prédiction en valeur absolue
                prediction_absolute = abs(prediction[0][0])

                # Afficher la prédiction en valeur absolue
                message = f"La prédiction des ventes est : {prediction_absolute}"
                return render(request, 'prediction.html', {'prediction': message})
            else:
                error_message = "Les valeurs de ventes mensuelles doivent être comprises entre 1000 et 100000."
                return render(request, 'prediction.html', {'error': error_message})
        except Exception as e:
            error_message = f"Une erreur s'est produite : {str(e)}"
            return render(request, 'prediction.html', {'error': error_message})

    # Si la méthode HTTP est GET, afficher l'interface de prédiction des ventes
    months = range(1, 13)  # Liste des mois de 1 à 12
    return render(request, 'interface.html', {'months': months})
   
def like_post(request, post_id):
    post = YourModel.objects.get(pk=post_id)
    post.likes += 1
    post.save()
    return redirect('like_post', post_id=post_id)

def dislike_post(request, post_id):
    post = YourModel.objects.get(pk=post_id)
    post.dislikes += 1
    post.save()
    return redirect('dislike_post', post_id=post_id)